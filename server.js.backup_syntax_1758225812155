// server.js - VERS√ÉO CORRETA PARA SEU PROJETO
const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');
const bodyParser = require('body-parser');
const path = require('path');

const app = express();
const PORT = 3001;

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(express.static('public'));

// Servir arquivos est√°ticos da raiz (incluindo logo-apae.png)
app.use(express.static(__dirname));

// Inicializar banco de dados SQLite
const db = new sqlite3.Database('./database/doacoes.db', (err) => {
  if (err) {
    console.error('Erro ao conectar com o banco de dados:', err.message);
  } else {
    console.log('Conectado ao banco de dados SQLite.');
  }
});

// Criar tabelas se n√£o existirem
db.serialize(() => {
  // Tabela de doadores com campos de endere√ßo
  db.run(`CREATE TABLE IF NOT EXISTS doadores (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nome TEXT NOT NULL,
    email TEXT,
    telefone1 TEXT NOT NULL,
    telefone2 TEXT,
    cpf TEXT UNIQUE,
    codigo_doador TEXT UNIQUE,
    cep TEXT,
    logradouro TEXT,
    numero TEXT,
    complemento TEXT,
    bairro TEXT,
    cidade TEXT,
    estado TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  // Tabela de doa√ß√µes
  db.run(`CREATE TABLE IF NOT EXISTS doacoes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    doador_id INTEGER,
    valor REAL NOT NULL,
    tipo TEXT NOT NULL,
    data_doacao TEXT NOT NULL,
    recorrente INTEGER DEFAULT 0,
    observacoes TEXT,
    parcelas_totais INTEGER DEFAULT 1,
    data_proxima_parcela TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (doador_id) REFERENCES doadores (id)
  )`);

  // Tabela de hist√≥rico de pagamentos
  db.run(`CREATE TABLE IF NOT EXISTS historico_pagamentos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    doacao_id INTEGER,
    data_pagamento TEXT NOT NULL,
    valor REAL NOT NULL,
    status TEXT DEFAULT 'Pago',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (doacao_id) REFERENCES doacoes (id)
  )`);

  // Tabela de parcelas futuras
  db.run(`CREATE TABLE IF NOT EXISTS parcelas_futuras (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    doacao_id INTEGER,
    numero_parcela INTEGER,
    data_vencimento TEXT NOT NULL,
    valor REAL NOT NULL,
    status TEXT DEFAULT 'Pendente',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (doacao_id) REFERENCES doacoes (id)
  )`);
});

// ==============================
// FUN√á√ïES AUXILIARES
// ==============================

// Gerar c√≥digo √∫nico do doador
function generateDoadorCode(nome, id) {
  const iniciais = nome.split(' ')
    .filter(palavra => palavra.length > 2)
    .map(p => p.charAt(0).toUpperCase())
    .join('')
    .substring(0, 3);
  return `D${id.toString().padStart(3, '0')}-${iniciais}`;
}

// Checar duplicatas
function checkPossibleDuplicates(nome, telefone1, cpf, callback) {
  const queries = [];
  const params = [];

  if (cpf && cpf.trim() !== '') {
    queries.push('cpf = ?');
    params.push(cpf.replace(/\D/g, ''));
  }
  if (nome && telefone1) {
    queries.push('(nome = ? AND telefone1 = ?)');
    params.push(nome, telefone1);
  }
  if (telefone1) {
    queries.push('(telefone1 = ? OR telefone2 = ?)');
    params.push(telefone1, telefone1);
  }

  if (queries.length === 0) {
    callback(null, []);
    return;
  }

  const sql = `SELECT * FROM doadores WHERE ${queries.join(' OR ')}`;
  
  db.all(sql, params, (err, rows) => {
    if (err) {
      callback(err, null);
    } else {
      callback(null, rows || []);
    }
  });
}

// ==============================
// ROTAS DA API - DOA√á√ïES
// ==============================

// Listar todas as doa√ß√µes
app.get('/api/doacoes', (req, res) => {
  const sql = `
    SELECT d.*, don.nome as nome_doador, don.codigo_doador, don.telefone1, don.telefone2
    FROM doacoes d
    LEFT JOIN doadores don ON d.doador_id = don.id
    ORDER BY d.data_doacao DESC
  `;
  
  db.all(sql, [], (err, rows) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    res.json(rows);
  });
});

// Buscar doa√ß√£o espec√≠fica por ID
app.get('/api/doacoes/:id', (req, res) => {
  const { id } = req.params;
  
  const sql = `
    SELECT d.*, 
           don.nome as nome_doador, 
           don.codigo_doador, 
           don.telefone1,
           don.telefone2,
           don.cpf,
           don.email,
           don.cep,
           don.logradouro,
           don.numero,
           don.complemento,
           don.bairro,
           don.cidade,
           don.estado
    FROM doacoes d
    LEFT JOIN doadores don ON d.doador_id = don.id
    WHERE d.id = ?
  `;
  
  db.get(sql, [id], (err, row) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    if (!row) {
      res.status(404).json({ error: 'Doa√ß√£o n√£o encontrada' });
      return;
    }
    res.json(row);
  });
});

// Criar nova doa√ß√£o
app.post('/api/doacoes', (req, res) => {
  const {
    donor, contact, phone1, phone2, cpf,
    amount, type, date, recurrent, observations,
    forceCreate,
    cep, logradouro, numero, complemento, bairro, cidade, estado
  ,
    recorrente, parcelas, proxima_parcela} = req.body;

  const insertDoacao = (doadorId) => {
    // CORRE√á√ÉO v1.1.7: Usar dados de parcelas do frontend
    const parcelasTotais = recorrente ? (parcelas || 12) : 1;
    const valorDoacao = amount || 0;
    
    console.log('üíæ Salvando doa√ß√£o:', {
        doadorId,
        valor: valorDoacao,
        tipo: type,
        recorrente: recorrente ? 1 : 0,
        parcelas: parcelasTotais
    });
    
    db.run(
      `INSERT INTO doacoes (doador_id, valor, tipo, data_doacao, recorrente, observacoes, parcelas_totais)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [doadorId, valorDoacao, type, date, recorrente ? 1 : 0, observations, parcelasTotais],
      function(err) {
        if (err) {
          console.error('‚ùå Erro ao inserir doa√ß√£o:', err);
          res.status(500).json({ error: err.message });
          return;
        }
        
        const doacaoId = this.lastID;
        console.log('‚úÖ Doa√ß√£o criada com ID:', doacaoId);
        
        // Inserir primeiro pagamento no hist√≥rico
        db.run(
          `INSERT INTO historico_pagamentos (doacao_id, data_pagamento, valor, status)
           VALUES (?, ?, ?, ?)`,
          [doacaoId, date, valorDoacao, 'Pago'],
          (err) => {
            if (err) console.error('Erro ao inserir hist√≥rico:', err);
            else console.log('‚úÖ Hist√≥rico de pagamento criado');
          }
        );
        
        // Se for recorrente, criar parcelas futuras
        if (recorrente && parcelasTotais > 1) {
            console.log(`üìÖ Criando ${parcelasTotais - 1} parcelas futuras...`);
            
            for (let i = 2; i <= parcelasTotais; i++) {
                const dataVencimento = new Date(proxima_parcela || date);
                dataVencimento.setMonth(dataVencimento.getMonth() + (i - 2));
                
                db.run(
                  `INSERT INTO parcelas_futuras (doacao_id, numero_parcela, data_vencimento, valor, status)
                   VALUES (?, ?, ?, ?, ?)`,
                  [doacaoId, i, dataVencimento.toISOString().split('T')[0], valorDoacao, 'Pendente'],
                  (err) => {
                    if (err) console.error(`Erro ao criar parcela ${i}:`, err);
                  }
                );
            }
        }
        
        res.json({ 
            id: doacaoId, 
            doador_id: doadorId, 
            message: `Doa√ß√£o ${recorrente ? 'recorrente' : '√∫nica'} criada com sucesso!`,
            parcelas: parcelasTotais
        });
      }
    );
  }

  const proceed = () => {
    // Verificar se doador j√° existe
    db.get('SELECT * FROM doadores WHERE cpf = ? OR telefone1 = ?', [cpf, phone1], (err, doador) => {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      
      if (doador) {
        // Atualizar doador existente
        db.run(
          `UPDATE doadores SET nome=?, email=?, telefone1=?, telefone2=?, cpf=?,
           cep=?, logradouro=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?
           WHERE id=?`,
          [donor, contact, phone1, phone2, cpf, cep, logradouro, numero, complemento, bairro, cidade, estado, doador.id],
          (err) => {
            if (err) {
              res.status(500).json({ error: err.message });
              return;
            }
            insertDoacao(doador.id);
          }
        );
      } else {
        // Criar novo doador
        db.run(
          `INSERT INTO doadores (nome, email, telefone1, telefone2, cpf, cep, logradouro, numero, complemento, bairro, cidade, estado)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [donor, contact, phone1, phone2, cpf, cep, logradouro, numero, complemento, bairro, cidade, estado],
          function(err) {
            if (err) {
              res.status(500).json({ error: err.message });
              return;
            }
            const doadorId = this.lastID;
            const codigo = generateDoadorCode(donor, doadorId);
            db.run('UPDATE doadores SET codigo_doador=? WHERE id=?', [codigo, doadorId], (err) => {
              if (err) console.error(err.message);
              insertDoacao(doadorId);
            });
          }
        );
      }
    });
  };

  if (!forceCreate) {
    checkPossibleDuplicates(donor, phone1, cpf, (err, duplicates) => {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      if (duplicates.length > 0) {
        res.status(409).json({ error: 'DUPLICATES_FOUND', duplicates });
        return;
      }
      proceed();
    });
  } else {
    proceed();
  }
});

// Atualizar doa√ß√£o
app.put('/api/doacoes/:id', (req, res) => {
  const { id } = req.params;
  const { valor, tipo, data_doacao, recorrente, observacoes } = req.body;
  
  db.run(
    `UPDATE doacoes SET valor=?, tipo=?, data_doacao=?, recorrente=?, observacoes=?
     WHERE id=?`,
    [valor, tipo, data_doacao, recorrente, observacoes, id],
    function(err) {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      res.json({ message: 'Doa√ß√£o atualizada!', changes: this.changes });
    }
  );
});

// Deletar doa√ß√£o
app.delete('/api/doacoes/:id', (req, res) => {
  const { id } = req.params;
  
  // Deletar hist√≥rico primeiro
  db.run('DELETE FROM historico_pagamentos WHERE doacao_id=?', [id], (err) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    
    // Depois deletar a doa√ß√£o
    db.run('DELETE FROM doacoes WHERE id=?', [id], function(err) {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      res.json({ message: 'Doa√ß√£o exclu√≠da!', changes: this.changes });
    });
  });
});

// ==============================
// ROTAS DA API - DOADORES
// ==============================

// Buscar doador espec√≠fico por ID
app.get('/api/doadores/:id', (req, res) => {
  const { id } = req.params;
  
  db.get(`
    SELECT id, nome, email, telefone1, telefone2, cpf, codigo_doador,
           cep, logradouro, numero, complemento, bairro, cidade, estado
    FROM doadores 
    WHERE id = ?
  `, [id], (err, row) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    if (!row) {
      res.status(404).json({ error: 'Doador n√£o encontrado' });
      return;
    }
    res.json(row);
  });
});

// ==============================
// ROTAS DA API - HIST√ìRICO
// ==============================

// Buscar hist√≥rico de uma doa√ß√£o
app.get('/api/doacoes/:id/historico', (req, res) => {
  const { id } = req.params;
  
  db.all(
    'SELECT * FROM historico_pagamentos WHERE doacao_id = ? ORDER BY data_pagamento DESC',
    [id],
    (err, rows) => {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      res.json(rows || []);
    }
  );
});

// Adicionar pagamento ao hist√≥rico
app.post('/api/doacoes/:id/historico', (req, res) => {
  const { id } = req.params;
  const { data_pagamento, valor, status } = req.body;
  
  db.run(
    'INSERT INTO historico_pagamentos (doacao_id, data_pagamento, valor, status) VALUES (?, ?, ?, ?)',
    [id, data_pagamento, valor, status || 'Pago'],
    function(err) {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      res.json({ id: this.lastID, message: 'Pagamento adicionado!' });
    }
  );
});

// Deletar pagamento do hist√≥rico
app.delete('/api/historico/:id', (req, res) => {
  const { id } = req.params;
  
  db.run('DELETE FROM historico_pagamentos WHERE id = ?', [id], function(err) {
    if (err) {
      res.status(500).json({ error: err.message });

// Pagar parcela espec√≠fica
app.post('/api/doacoes/:id/pagar-parcela', (req, res) => {
  const { id } = req.params;
  const { numero_parcela, data_pagamento, valor } = req.body;
  
  console.log(`üí∞ PAGANDO PARCELA: ${numero_parcela} da doa√ß√£o ${id}`);
  console.log('üì¶ Dados recebidos:', { numero_parcela, data_pagamento, valor });
  
  db.run(
    'INSERT INTO historico_pagamentos (doacao_id, data_pagamento, valor, status) VALUES (?, ?, ?, ?)',
    [id, data_pagamento, valor, 'Pago'],
    function(err) {
      if (err) {
        console.log('‚ùå Erro:', err.message);
        return res.status(500).json({ error: err.message });
      }
      
      console.log(`‚úÖ Pagamento salvo: ID ${this.lastID}`);
      res.json({ 
        success: true,
        pagamento_id: this.lastID,
        message: `Parcela ${numero_parcela} paga!`
      });
    }
  );
});
      return;
    }
    res.json({ message: 'Pagamento exclu√≠do!', changes: this.changes });
  });
});

// ==============================
// ROTAS DA API - PARCELAS
// ==============================

// Buscar parcelas futuras de uma doa√ß√£o
app.get('/api/doacoes/:id/parcelas', (req, res) => {
  const { id } = req.params;
  
  db.all(
    'SELECT * FROM parcelas_futuras WHERE doacao_id = ? ORDER BY data_vencimento ASC',
    [id],
    (err, rows) => {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      res.json(rows || []);
    }
  );
});

// ==============================

// Rota para verificar duplicatas - Vers√£o 1.1.1
app.post('/api/doadores/check-duplicates', (req, res) => {
  const { nome, telefone1, cpf } = req.body;
  
  checkPossibleDuplicates(nome, telefone1, cpf, (err, duplicates) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    
    res.json(duplicates || []);
  });
});

// ==============================
// ROTAS DA API - RELAT√ìRIOS
// ==============================

// Relat√≥rio resumo
app.get('/api/relatorios/resumo', (req, res) => {
  const queries = [
    'SELECT COUNT(*) as total_doacoes FROM doacoes',
    'SELECT SUM(valor) as total_arrecadado FROM historico_pagamentos WHERE status = "Pago"',
    'SELECT COUNT(*) as doacoes_recorrentes FROM doacoes WHERE recorrente = 1',
    'SELECT COUNT(*) as total_pagamentos FROM historico_pagamentos WHERE status = "Pago"'
  ];
  
  Promise.all(queries.map(query => {
    return new Promise((resolve, reject) => {
      db.get(query, [], (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }))
  .then(results => {
    res.json({
      total_doacoes: results[0].total_doacoes || 0,
      total_arrecadado: results[1].total_arrecadado || 0,
      doacoes_recorrentes: results[2].doacoes_recorrentes || 0,
      total_pagamentos: results[3].total_pagamentos || 0
    });
  })
  .catch(err => res.status(500).json({ error: err.message }));
});

// Relat√≥rio completo para exporta√ß√£o
app.get('/api/relatorios/completo', (req, res) => {
  const queries = [
    'SELECT COUNT(DISTINCT doador_id) as total_doadores FROM doacoes',
    'SELECT COUNT(*) as total_doacoes FROM doacoes',
    'SELECT SUM(valor) as total_arrecadado FROM historico_pagamentos WHERE status = "Pago"',
    'SELECT COUNT(*) as doacoes_recorrentes FROM doacoes WHERE recorrente = 1'
  ];
  
  Promise.all(queries.map(query => {
    return new Promise((resolve, reject) => {
      db.get(query, [], (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }))
  .then(results => {
    // Buscar doa√ß√µes detalhadas
    db.all(`
      SELECT d.*, don.nome as nome_doador, don.codigo_doador, 
             don.telefone1, don.telefone2, don.cpf
      FROM doacoes d
      LEFT JOIN doadores don ON d.doador_id = don.id
      ORDER BY d.data_doacao DESC
      LIMIT 100
    `, [], (err, doacoes) => {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      
      res.json({
        total_doadores: results[0].total_doadores || 0,
        total_doacoes: results[1].total_doacoes || 0,
        total_arrecadado: results[2].total_arrecadado || 0,
        doacoes_recorrentes: results[3].doacoes_recorrentes || 0,
        doacoes: doacoes || []
      });
    });
  })
  .catch(err => res.status(500).json({ error: err.message }));
});

// ==============================
// ROTA PRINCIPAL
// ==============================

// Servir arquivos est√°ticos
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// ==============================
// INICIAR SERVIDOR
// ==============================

app.listen(PORT, () => {
  console.log(`\nüöÄ Sistema de Doa√ß√µes v1.1.0`);
  console.log(`üìç Servidor rodando na porta ${PORT}`);
  console.log(`üåê Acesse: http://localhost:${PORT}`);
  console.log(`‚úÖ Servidor iniciado com sucesso!\n`);
});

// Fechar conex√£o com o banco ao encerrar o servidor
process.on('SIGINT', () => {
  db.close((err) => {
    if (err) {
      console.error(err.message);
    }
    console.log('Conex√£o com o banco de dados fechada.');
    process.exit(0);
  });

// Pagar parcela espec√≠fica - v1.2.3
  }
  
  // Inserir pagamento no hist√≥rico
  db.run(
    'INSERT INTO historico_pagamentos (doacao_id, data_pagamento, valor, status) VALUES (?, ?, ?, ?)',
    [id, data_pagamento, valor, 'Pago'],
    function(err) {
      if (err) {
        console.error('‚ùå Erro SQL:', err);
        return res.status(500).json({ error: 'Erro ao salvar pagamento: ' + err.message });
      }
      
      console.log(`‚úÖ Pagamento salvo com ID ${this.lastID}`);
      
      // Atualizar parcela futura (opcional)
      db.run(
        'UPDATE parcelas_futuras SET status = ? WHERE doacao_id = ? AND numero_parcela = ?',
        ['Pago', id, numero_parcela],
        (updateErr) => {
          if (updateErr) {
            console.warn('‚ö†Ô∏è Parcela futura n√£o atualizada:', updateErr.message);
          } else {
            console.log('‚úÖ Parcela futura atualizada');
          }
        }
      );
      
      res.json({ 
        success: true,
        pagamento_id: this.lastID,
        message: `Parcela ${numero_parcela} paga com sucesso!`
      });
    }
  );
});

});